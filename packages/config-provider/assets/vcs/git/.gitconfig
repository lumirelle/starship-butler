# User Information
[user]
# NOTICE: Please replace the following with your own information.
name = Lumirelle
email = shabbyacc@outlook.com
[credential "https://gitee.com"]
provider = generic

# Core Settings
[core]
ignorecase = false
editor = nvim # Or replace with your preferred editor.
[feature]
# Will enable some default configurations to better handle a large number of files, include `index.version=4`. See
# https://git-scm.com/docs/git-config#Documentation/git-config.txt-featuremanyFiles.
manyFiles = true

# Repository Initialization
[init]
defaultBranch = main

# Working with Branches
[branch]
sort = -committerdate
[diff]
algorithm = histogram
context = 5
[merge]
autostash = true
conflictstyle = zdiff3
ff = no
[rebase]
autostash = true
autosquash = true
updateRefs = true # See https://juejin.cn/post/7267567645493674021.
[rerere]
enabled = true
[tag]
sort = taggerdate

# Working with Remotes
[fetch]
prune = true
pruneTags = true
[pull]
rebase = true
[push]
autoSetupRemote = true
default = current
followTags = true

# Log
[log]
date = short
decoration = short

# Aliases
[alias]
# @group Setup & User Info
setup = "!f() { \
  if [ -z \"$1\" ]; then\
    echo 'Please provide a user name.'; \
    return 1; \
  fi; \
  if [ -z \"$2\" ]; then\
    echo 'Please provide a user email.'; \
    return 1; \
  fi; \
  git config set user.name \"$1\"; \
  git config set user.email \"$2\"; \
}; f"
setup-blame = "!f() { \
  git config set blame.ignoreRevsFile .git-blame-ignore-revs; \
}; f"
whoami = "!f() { \
  git config get user.name; \
  git config get user.email; \
}; f"
me = whoami
# @group Basic Operations
# Change & Discard
# @name - Discard
# @description - Discard changes to specified file[s].
# @parameters - One or more file paths.
#   - If the file is tracked, then restore the file[s] to the working directory.
#   - If the file is untracked, then delete the file[s].
discard = "!f() { \
  if [ -z \"$1\" ]; then \
      echo 'Nothing specified, nothing discarded.'; \
      YELLOW='\\e[0;33m'; \
      NC='\\e[0m'; \
      echo -e \"${YELLOW}hint: Maybe you wanted to say 'git disadd .'?${NC}\"; \
      return 0; \
    fi; \
  if git ls-files --error-unmatch -- \"$@\" >/dev/null 2>&1; then \
    git restore --staged --worktree -- \"$@\"; \
  else \
    for f in \"$@\"; do \
      if ! [ -e \"$f\" ]; then \
        echo \"Warning: $f does not exist!\"; \
        continue; \
      fi; \
      git clean -fd -- \"$f\" >/dev/null 2>&1; \
    done; \
  fi; \
}; f"
x = discard
# Add & Disadd
a = add
disadd = "!f() { \
    if [ -z \"$1\" ]; then \
      echo 'Nothing specified, nothing disadded.'; \
      YELLOW='\\e[0;33m'; \
      NC='\\e[0m'; \
      echo -e \"${YELLOW}hint: Maybe you wanted to say 'git disadd .'?${NC}\"; \
      return 0; \
    fi; \
    git reset HEAD -- \"$@\"; \
}; f"
u = disadd
# Commit & Uncommit
c = commit
commit-with-message = commit --message
cm = commit-with-message
commit-amend = commit --amend --no-edit
ca = commit-amend
commit-amend-with-editing = commit --amend
ce = commit-amend-with-editing
uncommit = reset --soft HEAD^ # Back to the staging area
uc = uncommit
# Make Special Commit
commit-work-in-progress = "!git commit-with-message 'chore: wip'"
cwip = commit-work-in-progress
commit-readme = "!git commit-with-message 'docs: update README.md'"
crdm = commit-readme
commit-dependencies = "!git commit-with-message 'chore: update dependencies'"
cdep = commit-dependencies
# @group Work with Branches
b = branch
bl = branch --list
# @name - Branch Delete
# @description - Delete branch with more flexible options.
# @parameters - One branch name and optional flags:
#   - `-h` or `--help`: Show help information.
#   - `-o` or `--origin`: Delete the branch from remote (origin) only.
#   - `-a` or `--all`: Delete the branch from both local and remote (origin).
#   - `-f` or `--force`: Force delete the local branch.
#   - If neither `-o`/`--origin` nor `-a`/`--all` is provided, delete the branch from local only.
# @examples
#   - `git branch-delete feature/login`: Delete the local branch `feature/login`.
#   - `git branch-delete -o feature/login`: Delete the remote branch `feature/login`.
#   - `git branch-delete --all feature/login`: Delete both local and remote (origin) branches `feature/login`.
#   - `git branch-delete -a -f feature/login`: Force delete the local branch and delete the remote (origin) branch `feature/login`.
branch-delete = "!f() { \
    origin=false; \
    all=false; \
    force=false; \
    branch_name=""; \
    for arg in \"$@\"; do \
      case \"$arg\" in \
        -o|--origin) origin=true ;; \
        -a|--all) all=true ;; \
        -f|--force) force=true ;; \
        *) branch_name=\"$arg\" ;; \
      esac; \
    done; \
    if [ -z \"$branch_name\" ]; then \
      echo 'Please provide a branch name to delete.'; \
      return 1; \
    fi; \
    if [ \"$origin\" = true ] && [ \"$all\" = true ]; then \
      echo 'Cannot use both --origin and --all options together.'; \
      return 1; \
    fi; \
    if [ \"$all\" = true ]; then \
      if [ \"$force\" = true ]; then \
        git branch --delete --force \"$branch_name\"; \
      else \
        git branch --delete \"$branch_name\"; \
      fi; \
      git push origin \":refs/heads/$branch_name\"; \
    elif [ \"$origin\" = true ]; then \
      git push origin \":refs/heads/$branch_name\"; \
    else \
      if [ \"$force\" = true ]; then \
        git branch --delete --force \"$branch_name\"; \
      else \
        git branch --delete \"$branch_name\"; \
      fi; \
    fi; \
}; f"
bx = branch-delete
# Stash
s = stash
sl = stash list
ss = stash show
sa = stash apply
sp = stash pop
sx = stash drop
# Switch
sw = switch
switch-new = switch --create
swn = switch-new
# Merge
merge-with-default-message = "!f() { \
  current_branch=$(git branch --show-current); \
  git merge \"$1\" --no-ff --message \"chore: merge branch $1 into $current_branch\"; \
}; f"
m = merge-with-default-message
merge-abort = merge --abort
mz = merge-abort
merge-continue = merge --continue
mc = merge-continue
# Rebase
r = rebase
rebase-abort = rebase --abort
rz = rebase-abort
rebase-continue = rebase --continue
rc = rebase-continue
# Reset
rs = reset
# Revert
rv = revert
revert-abort = revert --abort
rvz = revert-abort
revert-continue = revert --continue
rvc = revert-continue
# Cherry-pick
cp = cherry-pick
cherry-pick-abort = cherry-pick --abort
cpz = cherry-pick-abort
cherry-pick-continue = cherry-pick --continue
cpc = cherry-pick-continue
# Tag
tag-wrapper = "!f() { \
  if [ -z \"$2\" ]; then \
    git tag --annotate \"$1\" --message \"$2\"; \
  else \
    git tag \"$@\"; \
  fi; \
}; f"
t = tag-wrapper
tag-list = tag --list
tl = tag-list
tag-delete = "!f() { \
  origin=false; \
  all=false; \
  tag_name=""; \
  for $arg in \"$@\"; do \
    case $arg in \
      -r|--origin) origin=true ;; \
      -a|--all) all=true ;; \
      *) tag_name=\"$arg\" ;; \
    esac; \
  done; \
  if [ -z \"$tag_name\" ] && [ \"$all\" = false ]; then \
    echo 'Please provide a tag name to delete.'; \
    return 1; \
  fi; \
  if [ \"$origin\" = true ] && [ \"$all\" = true ]; then \
    echo 'Cannot use both --origin and --all options together.'; \
    return 1; \
  fi; \
  if [ \"$all\" = true ]; then \
    git tag --delete \"$tag_name\"; \
    git push origin \":refs/tags/$tag_name\"; \
  elif [ \"$origin\" = true ]; then \
    git push origin \":refs/tags/$tag_name\"; \
  else \
    git tag --delete \"$tag_name\"; \
  fi; \
}; f"
tx = tag-delete
# @region Work with Remote
# Remote
re = remote
remote-new = "!f() { \
  if [ -z \"$2\" ]; then \
    git remote add origin \"$1\"; \
  else \
    git remote add \"$1\" \"$2\"; \
  fi; \
}; f"
ren = remote-new
remote-list = remote --verbose
rel = remote-list
remote-remove = remote remove
rex = remote-remove
# Fetch
f = fetch
# Pull
l = pull
# Push
p = push
push-force = push --force
pf = push-force
push-delete = push --delete
px = push-delete
# @region Log
logs = log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit
log = log -1 HEAD --stat
# @region Aliases
aliases = "!git config --get-regexp ^alias\\. | sed -e s/^alias\\.// -e s/\\ /\\ =\\ /"
