# ----------------------------------- User ----------------------------------- #
[user]
# NOTICE: Please replace the following with your own information.
name = Lumirelle
email = shabbyacc@outlook.com

[credential "https://gitee.com"]
provider = generic

# ----------------------------------- Core ----------------------------------- #
[core]
editor = code --wait
ignorecase = false

[feature]
# Will enable some default configurations to better handle a large number of files, include `index.version=4`.
# See https://git-scm.com/docs/git-config#Documentation/git-config.txt-featuremanyFiles.
manyFiles = true

# --------------------------------- Repo init -------------------------------- #
[init]
defaultBranch = main

# ---------------------------- Work with branches ---------------------------- #

[branch]
sort = -committerdate

[diff]
algorithm = histogram
context = 5

[merge]
autostash = true
conflictstyle = zdiff3
ff = no

[rebase]
autostash = true
autosquash = true
# See https://juejin.cn/post/7267567645493674021.
updateRefs = true

[rerere]
enabled = true

[tag]
sort = taggerdate

# ----------------------------- Work with remote ----------------------------- #
[fetch]
prune = true
pruneTags = true

[pull]
rebase = true

[push]
autoSetupRemote = true
default = current
followtags = true

# ------------------------------------ Log ----------------------------------- #
[log]
date = short
decoration = short

# ----------------------------------- Alias ---------------------------------- #
[alias]
# =========================== ENHANCEMENTS ALIASES =========================== #
# >> Basic
# add
add-all = add .
add-undo = reset HEAD --
add-all-undo = reset HEAD -- .
# discard
# Accepts one or more parameters:
#   - If the file is tracked, then restore the file[s] to the working directory.
#   - If the file is untracked, then delete the file[s].
discard = "!f() { \
  if git ls-files --error-unmatch -- \"$@\" >/dev/null 2>&1; then \
    git restore --staged --worktree -- \"$@\"; \
  else \
    for f in \"$@\"; do \
      if ! [ -e \"$f\" ]; then \
        echo \"Warning: '$f' does not exist!\"; \
        continue; \
      fi; \
      git clean -fd -- \"$f\" >/dev/null 2>&1; \
    done; \
  fi; \
}; f"
discard-all = "!git restore --staged --worktree . && git clean -df"
# commit
commit-with-message = commit --message
commit-undo = reset --soft HEAD^ # Back to the staging area
# add & commit
add-all-then-commit = "!f() { \
  git add-all; \
  git commit; \
}; f"
add-all-then-commit-with-message = "!f() { \
  git add-all; \
  git commit-with-message \"$@\"; \
}; f"
# Only for a node package, which requires `czg` to be installed
add-all-then-czg = "!f() { \
  git add-all; \
  git czg \"$@\";\
}; f"
# amend commit
amend-commit = commit --amend --no-edit
add-all-then-amend-commit = "!f() { \
  git add-all; \
  git amend-commit; \
}; f"
amend-commit-with-edit = commit --amend
add-all-then-amend-commit-with-edit = "!f() { \
  git add-all; \
  git amend-commit-with-edit \"$@\"; \
}; f"
# wip commit
work-in-progress = "!git add-all && git commit-with-message 'chore: wip'"
work-in-progress-undo = "!git log -n 1 | grep -q -c 'chore: wip' && git reset HEAD~1"

# >> Work with branches
# branch
branch-list-localremote = branch --all
branch-delete-local = branch --delete
branch-force-delete-local = branch --delete --force
# Accepts one or two parameters:
#   - If one parameter is provided, it is treated as the branch name to be deleted from the `origin` remote.
#   - If two parameters are provided, the first is treated as the remote name, and the second as the branch name to be
#     deleted from that remote.
branch-delete-remote = "!f() {\
  if [ -z \"$2\" ]; then \
    git push --delete origin \"$1\"; \
  else \
    git push --delete \"$1\" \"$2\"; \
  fi; \
}; f"
# Accepts one or two parameters:
#   - If one parameter is provided, it is treated as the branch name to be deleted both locally and from the `origin`
#     remote.
#   - If two parameters are provided, the first is treated as the remote name, and the second as the branch name to be
#     deleted both locally and from that remote.
branch-delete-localremote = "!f() { \
  if [ -z \"$2\" ]; then \
    git branch-delete-local \"$1\"; \
    git branch-delete-remote \"$1\"; \
  else \
    git branch-delete-local \"$2\"; \
    git branch-delete-remote \"$1\" \"$2\"; \
  fi; \
}; f"
branch-move = branch --move
# Accepts two or three parameters:
#   - If two parameters are provided, the first is treated as the old branch name, and the second as the new branch
#     name. The command renames the local branch and updates the remote accordingly.
#   - If three parameters are provided, the first is treated as the remote name, the second as the old branch name, and
#     the third as the new branch name. The command deletes the old branch from the specified remote, renames the local
#     branch, and updates the remote accordingly.
branch-move-localremote = "!f() { \
  if [ -z \"$3\" ]; then \
    git branch-delete-remote \"$1\" \"$2\"; \
    git branch-move \"$2\" \"$3\"; \
    git push-set-upstream; \
  else \
    git branch-delete-remote \"$1\"; \
    git branch-move \"$1\" \"$2\"; \
    git push-set-upstream; \
  fi; \
}; f"
# stash
stash-push = stash push
stash-list = stash list
stash-undo = stash pop
stash-drop = stash drop
# branch & switch
switch-new = switch --create
# merge
merge-with-default-message = "!f() { \
  current_branch=$(git branch --show-current); \
  git merge \"$1\" --no-ff --message \"chore: merge branch '$1' into '$current_branch'\"; \
}; f"
merge-abort = merge --abort
merge-continue = merge --continue
# rebase
rebase-abort = rebase --abort
rebase-continue = rebase --continue
# cherry-pick
cherry-pick-abort = cherry-pick --abort
cherry-pick-continue = cherry-pick --continue
# tag
tag-new = "!f() { \
  if ! (git branch-list-local \"$1\" >/dev/null 2>&1); then \
    echo \"Error: Branch with the same name as the tag '$1' already exists!\"; \
    exit 1; \
  fi; \
  git tag \"$@\"; \
}; f"
tag-list-remote = ls-remote --tags
tag-delete-local = tag --delete
tag-delete-remote = "!f() { \
  if [ -z \"$2\" ]; then \
    git push-delete origin \"$1\"; \
  else \
    git push-delete \"$1\" \"$2\"; \
  fi; \
}; f"

# >> Work with remote
# remote
remote-new = "!f() { \
  if [ -z \"$2\" ]; then \
    git remote add origin \"$1\"; \
  else \
    git remote add  \"$1\" \"$2\"; \
  fi; \
}; f"
remote-list = remote --verbose
remote-remove = remote remove
# pull
pull-set-upstream = "!f() { \
  current_branch=$(git branch --show-current); \
  git pull --set-upstream origin \"$current_branch\"; \
}; f"
# push
push-set-upstream = "!f() { \
  current_branch=$(git branch --show-current); \
  git push --set-upstream origin \"$current_branch\"; \
}; f"
push-force = push --force
push-delete = push --delete
# pull & push
pull-then-push = pull && push

# >> Log
logs = log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit
log = log -1 HEAD --stat

# >> Alias
aliases = "!git config --get-regexp ^alias\\. | sed -e s/^alias\\.// -e s/\\ /\\ =\\ /"

# ============================ SHORTCUTS ALIASES ============================= #
# SUFFIX INTRODUCTION
#   <TO SPECIFY ADDITIONAL BEHAVIOR>
#   `n`:    `add | new`
#   `s`:    `list | show`
#   `x`:    `discard | delete | drop`, which means **drop things** we don't need any more
#   `u`:    `undo`, which means recover the status **after an operation is completed**
#   `mv`:   `move | rename`
#   <TO SPECIFY TARGET>
#   `a`:    `all`
#   `bt`:    `both | localremote`
#   `re`:    `remote`
#   <TO SPECIFY PARAMETERS>
#   `up`:   with `--set-upstream` parameter
#   `f`:    with `--force` parameter
#   `ms`:   with `--message` parameter
#   `i`:    with `--edit` parameter
#   `z`:    with `--abort` parameter
#   `c`:    with `--continue` parameter
# >> Basic
# add: a
a = add
aa = add-all
au = add-undo
aau = add-all-undo
# discard: x
x = discard
xa = discard-all
# commit: cm
cm = commit
cmms = commit-with-message
cmu = commit-undo
# czg: cg
cz = czg
# add & commit: adcm
aacm = add-all-then-commit
aacmms = add-all-then-commit-with-message
# add & commit (czg): adcz
aacz = add-all-then-czg
# amend commit: md
md = amend-commit
mdi = amend-commit-with-edit
aamd = add-all-then-amend-commit
aamdi = add-all-then-amend-commit-with-edit
# work-in-progress: wip
wip = work-in-progress
wipu = work-in-progress-undo

# >> Work with branches
# branch: br
brn = branch
brs = branch-list-localremote
brx = branch-delete-local
brxf = branch-delete-local-force
brxre = branch-delete-remote
brxbt = branch-delete-localremote
brmv = branch-move
brmvbt = branch-move-localremote
# stash: st
stn = stash-push
sts = stash-list
stu = stash-undo
stx = stash-drop
# switch: sw
sw = switch
swn = switch-new
# merge: mg
mg = merge-with-default-message
mgz = merge-abort
mgc = merge-continue
# rebase: rb
rb = rebase
rbz = rebase-abort
rbc = rebase-continue
# reset: rs
rs = reset
# revert: rv
rv = revert
# cherry-pick: cp
cp = cherry-pick
cpz = cherry-pick-abort
cpc = cherry-pick-continue
# tag: tg
tgn = tag-new
tgs = tag-list-remote
tgx = tag-delete-local
tgxre = tag-delete-remote

# remote: re
ren = remote-new
res = remote-list
rex = remote-remove
# fetch: ft
ft = fetch
# pull: pl
pl = pull
plup = pull-set-upstream
# push: ps
ps = push
psup = push-set-upstream
psf = push-force
psx = push-delete
# pull & push: plps
plps = pull-then-push
